/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds
 */

plugins
{
	// Reckon versioning plugin
	// Usage: ./gradlew [TASK] -Preckon.scope=minor|major -Preckon.stage=rc|final (default is minor and first stage in the list (ordered alphabetically)) -Dorg.ajoberstar.grgit.auth.username=<token>
	id 'org.ajoberstar.reckon' version '0.12.0'

	// Grgit plugin
	id 'org.ajoberstar.grgit' version '4.0.2'
}

// Load build's functions
apply from: "build.groovy"

//
// Versioning (must be the first plugin setup)
//

// Add this setion to avoid:
// 	Could not evaluate onlyIf predicate for task ':reckonTagCreate'.
// 	> java.lang.String cannot be cast to org.ajoberstar.reckon.gradle.ReckonPlugin$DelayedVersion
gradle.taskGraph.beforeTask { Task task ->
	if (task.name == 'reckonTagCreate') {
		project.version = originalProjectVersionObject
	}
}
gradle.taskGraph.afterTask { Task task ->
	if (task.name == 'reckonTagCreate') {
		project.version = originalProjectVersionObject.toString()
	}
}

// The Reckon plugin
reckon {
	scopeFromProp()
	stageFromProp("${reckon_staging_stage_name}","${reckon_production_stage_name}","${reckon_FINAL_stage_name}")
}

// Reckon helpers
task printVersion
task stampVersion(dependsOn: reckonTagCreate)
task publishVersion(dependsOn: reckonTagPush)

// These properties must be defined after the reckon plugin is set up!
ext.originalProjectVersionObject = project.version
ext.productVersion = manifestVersion()
ext.productTag = manifestVersion(false)

// Pre-Defined project properties
project.description = 'A simple Gradle based Semantic Versioning (2.0) facilitator via smart Git tagging'

// Pre-Defined project properties
//project.description = 'The Echo demo product'
project.version = originalProjectVersionObject.toString()

//
// Works with org.ajoberstar.grgit plugin
//

task applicableTagCreate {
	description = 'Tags the current head with the applicable version name'

	def tagName = productTag
	def tagMessage = null

	doFirst {
		if (project.hasProperty(CONST_DESIGNATED_TAG_MESSAGE_PROJECT_PROPERTY_NAME) == true && project.ext[CONST_DESIGNATED_TAG_MESSAGE_PROJECT_PROPERTY_NAME].trim().isEmpty() == false) {
			tagMessage = project.ext[CONST_DESIGNATED_TAG_MESSAGE_PROJECT_PROPERTY_NAME]
		}
		else {
			tagMessage = "Release of ${tagName}"
		}
	}

	doLast {
		grgit.tag.add {
			name = tagName
			message = tagMessage
			force = true
//			tagger = new Person(vcsUsername,vcsUseremail)
		}

		println "Applicable tag cretaed: ${productTag}"
	}
}

task applicableTagDestroy {
	description = 'Removes applicable tag from GIT'

	doLast {
		grgit.tag.remove {
			names = [productTag]
		}

		println "Applicable tag destroyed: ${productTag}"
	}
}

// Requires the use of "-Dorg.ajoberstar.grgit.auth.username" (with a proper token) for authentication
task gitPush {
	description = "Pushes current branch's committed changes to origin repo"

	doLast {
		grgit.push {
			tags = true
			force = true
//			dryRun = true
		}
	}
}

task gitPull {
	description = "Pulls origin repo's committed changes to current branch"

	doLast {
		grgit.pull {
			rebase = true
		}
	}
}

// Applicable version helpers
task printApplicableVersion {
	doLast {
		// Note: the word 'Manifested' must remain as the Pipeline is using this task and filters the output by this word!
		println "Manifested version: ${productTag}"
	}
}
task stampApplicableVersion(dependsOn: applicableTagCreate)
task publishApplicableVersion(dependsOn: [stampApplicableVersion,gitPush]) {
	gitPush.mustRunAfter stampApplicableVersion
}

// The most recent version that exists in the VCS (last generated tag)
task printLatestVersion {
	doLast {
		def latestTag = obtainLatestTag()
		def latestTagName = latestTag.name
		def latestTagDateTime = latestTag.dateTime

		println "Recent version: ${latestTagName}@${latestTagDateTime}"
	}
}
